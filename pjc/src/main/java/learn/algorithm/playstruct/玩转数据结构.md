# 复杂度分析


## 均摊复杂度分析

## 复杂度震荡

# 栈和队列

IDE 的撤销操作 undo 就是一个用栈来维护

系统函数调用栈

## 栈应用 括号匹配 Valid Parentheses

leetcode 题目

https://leetcode-cn.com/problems/valid-parentheses/


# 链表 与递归


# 树

## 二叉树

### 二叉树的遍历

#### 三种遍历方式

java语言实现：https://zhuanlan.zhihu.com/p/25632253

(1). 先序遍历

(2). 中序遍历

(3). 后序遍历

三种遍历方式，也就是遍历的顺序不一样。

先序遍历: "根左右"，遍历的顺序: 根节点->左节点->右节点。

中序遍历: "左根右"，遍历的顺序: 左节点->根节点->右节点。

后序遍历: "左右根"，遍历的顺序: 左节点->右节点->根节点。


### 二分搜索树

元素有可比较性

中序遍历 就是元素排序后的顺序

后序遍历 先处理完孩子节点，再处理父节点,如控制内存


# 集合 映射

Java有三种Set的实现分别是HashSet,TreeSet,LinkedHashSet

>HashSet 将元素存在 哈希表中，最高效，但是不考虑元素的顺序

>LinkedHashSet也将元素存在哈希表中，但是还附带一条链表，记录着插入的顺序。性能比HashSet稍微低一点。

>TreeSet将元素存在红黑树中，按照值的顺序排列，性能低于HashSet


## demo 

统计单词 去重


## 映射 map




# 基于堆---优先队列

Heap

二叉堆 
完全二叉树
最大堆，最小堆，以节点为定义

>以数组存放堆，左右孩子怎么算呢？
从0开始 从1开始


replace 操作
>取出堆顶元素，再插入一个新元素

heapify 操作  复杂度 O(n),相比于一个一个加入到数组中（O(nlong n)）
>将任意数组转成堆 


堆排序

# leetcode 题目

集合
https://leetcode-cn.com/problems/unique-morse-code-words/
https://leetcode-cn.com/problems/intersection-of-two-arrays/


映射
https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/





# 算法复杂性分析

树比链表更快




