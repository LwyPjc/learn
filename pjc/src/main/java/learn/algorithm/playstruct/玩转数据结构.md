# 复杂度分析


## 均摊复杂度分析

## 复杂度震荡

# 栈和队列

IDE 的撤销操作 undo 就是一个用栈来维护

系统函数调用栈

## 栈应用 括号匹配 Valid Parentheses

leetcode 题目

https://leetcode-cn.com/problems/valid-parentheses/


# 链表 与递归


# 树

## 二叉树

### 二叉树的遍历

#### 三种遍历方式

java语言实现：https://zhuanlan.zhihu.com/p/25632253

(1). 先序遍历

(2). 中序遍历

(3). 后序遍历

三种遍历方式，也就是遍历的顺序不一样。

先序遍历: "根左右"，遍历的顺序: 根节点->左节点->右节点。

中序遍历: "左根右"，遍历的顺序: 左节点->根节点->右节点。

后序遍历: "左右根"，遍历的顺序: 左节点->右节点->根节点。


### 二分搜索树

元素有可比较性

中序遍历 就是元素排序后的顺序

后序遍历 先处理完孩子节点，再处理父节点,如控制内存


# 集合 映射

Java有三种Set的实现分别是HashSet,TreeSet,LinkedHashSet

>HashSet 将元素存在 哈希表中，最高效，但是不考虑元素的顺序

>LinkedHashSet也将元素存在哈希表中，但是还附带一条链表，记录着插入的顺序。性能比HashSet稍微低一点。

>TreeSet将元素存在红黑树中，按照值的顺序排列，性能低于HashSet


## demo 

统计单词 去重


## 映射 map




# 基于堆---优先队列

Heap

二叉堆 
完全二叉树
最大堆，最小堆，以节点为定义

>以数组存放堆，左右孩子怎么算呢？
从0开始 从1开始


replace 操作
>取出堆顶元素，再插入一个新元素

heapify 操作  复杂度 O(n),相比于一个一个加入到数组中（O(nlong n)）
>将任意数组转成堆 


堆排序


索引堆
二项堆
斐波那契堆


# 线段树

Segment Tree 区间树

>区间染色问题 区间查询
1. 使用数组 O(n) 更新 查询；
2. 使用线段树 O(log n)

线段树： 区间是固定的
也是一个二叉树 是一颗平衡二叉树 最大深度与最小深度的差不超过1
区间有 n 个元素，数组表示大约需要 4n 个位置。考虑的是静态空间


>线段树的update操作

>后序遍历

>懒惰更新 更新区间

>一维线段树 二维线段树

>链式树，动态树

>树状数组

>RMQ 问题


# Trie 字典树 前缀树

> 专门为处理字符串而设计

查询时 复杂度与树中有多少元素无关，而与要查询的字符串长度相关。O(单词长度)

从根节点遍历，到叶子节点为一个单词。

# 并查集 

孩子指向父亲

>连接和路径

union(q,p)
isConnected(p,q)

压缩路径优化 并查集
>希望树的深度越少越好



# 算法复杂性分析

树比链表更快


# leetcode 题目

集合
https://leetcode-cn.com/problems/unique-morse-code-words/
https://leetcode-cn.com/problems/intersection-of-two-arrays/


映射
https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/


优先队列
在一百万个元素中找出前100个元素。

>优先队列中一直维护当前可以看到的前100个元素。大还是小堆？这是相对的

https://leetcode-cn.com/problems/top-k-frequent-elements/


java 的优先队列
>PriorityQueue 默认是一个最小堆
比较器

``` java 有意思的写法

   public List<Integer> topKFrequent(int[] nums, int k) {

        TreeMap<Integer, Integer> map = new TreeMap<>();
        for(int num: nums){
            if(map.containsKey(num))
                map.put(num, map.get(num) + 1);
            else
                map.put(num, 1);
        }

        PriorityQueue<Integer> pq = new PriorityQueue<>(
                (a, b) -> map.get(a) - map.get(b)// 这里
            );
        for(int key: map.keySet()){
            if(pq.size() < k)
                pq.add(key);
            else if(map.get(key) > map.get(pq.peek())){// 这里 peek
                pq.remove();
                pq.add(key);
            }
        }

        LinkedList<Integer> res = new LinkedList<>();
        while(!pq.isEmpty())
            res.add(pq.remove());
        return res;
    }

```

## 线段树

>可使用预处理
https://leetcode-cn.com/problems/range-sum-query-immutable/

>https://leetcode-cn.com/problems/range-sum-query-mutable/


## Trie

>208

>211 类似正则表达式 匹配单词


>677 Trie 当作map 前缀单词和


### 更多Trie 操作

>删除操作


>空间问题
压缩字典树

>三分搜索树

>后缀树


```
# 字符串问题

>子串查询

>文件压缩 哈夫曼树

>模式匹配

>编译原理

>DNA 

```